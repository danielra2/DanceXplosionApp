{"version":3,"file":"joined-config.js","sourceRoot":"","sources":["../../../src/config/joined-config.ts"],"names":[],"mappings":"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","sourcesContent":["import { ILogger, IRemoteConfigClient, RemoteConfigClient, RemoteConfig, Source } from '@amplitude/analytics-core';\nimport { getDebugConfig } from '../helpers';\nimport { SessionReplayOptions } from '../typings/session-replay';\nimport { SessionReplayLocalConfig } from './local-config';\nimport {\n  SessionReplayLocalConfig as ISessionReplayLocalConfig,\n  PrivacyConfig,\n  SessionReplayConfigs,\n  SessionReplayJoinedConfig,\n  SessionReplayRemoteConfig,\n} from './types';\n\nexport const removeInvalidSelectorsFromPrivacyConfig = (privacyConfig: PrivacyConfig, loggerProvider: ILogger) => {\n  // This allows us to not search the DOM.\n  const fragment = document.createDocumentFragment();\n\n  const dropInvalidSelectors = (selectors: string[] | string = []): string[] | undefined => {\n    if (typeof selectors === 'string') {\n      selectors = [selectors];\n    }\n    selectors = selectors.filter((selector: string) => {\n      try {\n        fragment.querySelector(selector);\n      } catch {\n        loggerProvider.warn(`[session-replay-browser] omitting selector \"${selector}\" because it is invalid`);\n        return false;\n      }\n      return true;\n    });\n    if (selectors.length === 0) {\n      return undefined;\n    }\n    return selectors;\n  };\n  privacyConfig.blockSelector = dropInvalidSelectors(privacyConfig.blockSelector);\n  privacyConfig.maskSelector = dropInvalidSelectors(privacyConfig.maskSelector);\n  privacyConfig.unmaskSelector = dropInvalidSelectors(privacyConfig.unmaskSelector);\n  return privacyConfig;\n};\nexport class SessionReplayJoinedConfigGenerator {\n  private readonly localConfig: ISessionReplayLocalConfig;\n  private readonly remoteConfigClient: IRemoteConfigClient;\n\n  constructor(remoteConfigClient: IRemoteConfigClient, localConfig: ISessionReplayLocalConfig) {\n    this.localConfig = localConfig;\n    this.remoteConfigClient = remoteConfigClient;\n  }\n\n  async generateJoinedConfig(): Promise<SessionReplayConfigs> {\n    const config: SessionReplayJoinedConfig = { ...this.localConfig };\n    // Special case here as optOut is implemented via getter/setter\n    config.optOut = this.localConfig.optOut;\n    // We always want captureEnabled to be true, unless there's an override\n    // in the remote config.\n    config.captureEnabled = true;\n    let sessionReplayRemoteConfig: SessionReplayRemoteConfig | undefined;\n\n    try {\n      // Subscribe to remote config client to get the config (uses cache if available)\n      await new Promise<void>((resolve, reject) => {\n        this.remoteConfigClient.subscribe(\n          'configs.sessionReplay',\n          'all',\n          (remoteConfig: RemoteConfig | null, source: Source) => {\n            this.localConfig.loggerProvider.debug(\n              `Session Replay remote configuration received from ${source}:`,\n              JSON.stringify(remoteConfig, null, 2),\n            );\n\n            if (!remoteConfig) {\n              reject(new Error('No remote config received'));\n              return;\n            }\n\n            // remoteConfig is already filtered to 'configs.sessionReplay' namespace\n            const namespaceConfig = remoteConfig as SessionReplayRemoteConfig;\n            const samplingConfig = namespaceConfig.sr_sampling_config;\n            const privacyConfig = namespaceConfig.sr_privacy_config;\n            const targetingConfig = namespaceConfig.sr_targeting_config;\n\n            const ugcFilterRules = config.interactionConfig?.ugcFilterRules;\n            // This is intentionally forced to only be set through the remote config.\n            config.interactionConfig = namespaceConfig.sr_interaction_config;\n            if (config.interactionConfig && ugcFilterRules) {\n              config.interactionConfig.ugcFilterRules = ugcFilterRules;\n            }\n\n            // This is intentionally forced to only be set through the remote config.\n            config.loggingConfig = namespaceConfig.sr_logging_config;\n\n            if (samplingConfig || privacyConfig || targetingConfig) {\n              sessionReplayRemoteConfig = {};\n              if (samplingConfig) {\n                sessionReplayRemoteConfig.sr_sampling_config = samplingConfig;\n              }\n              if (privacyConfig) {\n                sessionReplayRemoteConfig.sr_privacy_config = privacyConfig;\n              }\n              if (targetingConfig) {\n                sessionReplayRemoteConfig.sr_targeting_config = targetingConfig;\n              }\n            }\n\n            // Resolve on first callback\n            resolve();\n          },\n        );\n      });\n    } catch (error) {\n      this.localConfig.loggerProvider.error('Failed to generate joined config: ', error);\n      config.captureEnabled = false;\n      return {\n        localConfig: this.localConfig,\n        joinedConfig: config,\n        remoteConfig: undefined,\n      };\n    }\n\n    if (!sessionReplayRemoteConfig) {\n      return {\n        localConfig: this.localConfig,\n        joinedConfig: config,\n        remoteConfig: sessionReplayRemoteConfig,\n      };\n    }\n\n    const {\n      sr_sampling_config: samplingConfig,\n      sr_privacy_config: remotePrivacyConfig,\n      sr_targeting_config: targetingConfig,\n    } = sessionReplayRemoteConfig;\n    if (samplingConfig && Object.keys(samplingConfig).length > 0) {\n      if (Object.prototype.hasOwnProperty.call(samplingConfig, 'capture_enabled')) {\n        config.captureEnabled = samplingConfig.capture_enabled;\n      } else {\n        config.captureEnabled = false;\n      }\n\n      if (Object.prototype.hasOwnProperty.call(samplingConfig, 'sample_rate')) {\n        config.sampleRate = samplingConfig.sample_rate;\n      }\n    } else {\n      // If config API response was valid (ie 200), but no config returned, assume that\n      // customer has not yet set up config, and use sample rate from SDK options,\n      // allowing for immediate replay capture\n      config.captureEnabled = true;\n      this.localConfig.loggerProvider.debug(\n        'Remote config successfully fetched, but no values set for project, Session Replay capture enabled.',\n      );\n    }\n\n    // Remote config join acts somewhat like a left join between the remote and the local\n    // config. That is, remote config has precedence over local values as with sampling.\n    // However, non conflicting values will be added to the lists.\n    // Here's an example to illustrate:\n    //\n    // Remote config:   {'.selector1': 'MASK',   '.selector2': 'UNMASK'}\n    // Local config:    {'.selector1': 'UNMASK',                         '.selector3': 'MASK'}\n    //\n    // Resolved config: {'.selector1': 'MASK',   '.selector2': 'UNMASK', '.selector3': 'MASK'}\n    // config.privacyConfig = {\n    //   ...(config.privacyConfig ?? {}),\n    //   ...remotePrivacyConfig,\n    // };\n\n    if (remotePrivacyConfig) {\n      const localPrivacyConfig: PrivacyConfig = config.privacyConfig ?? {};\n\n      const joinedPrivacyConfig: Required<PrivacyConfig> & { blockSelector: string[] } = {\n        defaultMaskLevel: remotePrivacyConfig.defaultMaskLevel ?? localPrivacyConfig.defaultMaskLevel ?? 'medium',\n        blockSelector: [],\n        maskSelector: [],\n        unmaskSelector: [],\n      };\n\n      const privacyConfigSelectorMap = (privacyConfig: PrivacyConfig): Record<string, 'mask' | 'unmask' | 'block'> => {\n        const selectorMap: Record<string, 'mask' | 'unmask' | 'block'> = {};\n        if (typeof privacyConfig.blockSelector === 'string') {\n          privacyConfig.blockSelector = [privacyConfig.blockSelector];\n        }\n\n        for (const selector of privacyConfig.blockSelector ?? []) {\n          selectorMap[selector] = 'block';\n        }\n        for (const selector of privacyConfig.maskSelector ?? []) {\n          selectorMap[selector] = 'mask';\n        }\n        for (const selector of privacyConfig.unmaskSelector ?? []) {\n          selectorMap[selector] = 'unmask';\n        }\n        return selectorMap;\n      };\n\n      const selectorMap: Record<string, 'mask' | 'unmask' | 'block'> = {\n        ...privacyConfigSelectorMap(localPrivacyConfig),\n        ...privacyConfigSelectorMap(remotePrivacyConfig),\n      };\n\n      for (const [selector, selectorType] of Object.entries(selectorMap)) {\n        if (selectorType === 'mask') {\n          joinedPrivacyConfig.maskSelector.push(selector);\n        } else if (selectorType === 'block') {\n          joinedPrivacyConfig.blockSelector.push(selector);\n        } else if (selectorType === 'unmask') {\n          joinedPrivacyConfig.unmaskSelector.push(selector);\n        }\n      }\n\n      config.privacyConfig = removeInvalidSelectorsFromPrivacyConfig(\n        joinedPrivacyConfig,\n        this.localConfig.loggerProvider,\n      );\n    }\n\n    if (targetingConfig && Object.keys(targetingConfig).length > 0) {\n      config.targetingConfig = targetingConfig;\n    }\n\n    this.localConfig.loggerProvider.debug(\n      JSON.stringify({ name: 'session replay joined config', config: getDebugConfig(config) }, null, 2),\n    );\n\n    return {\n      localConfig: this.localConfig,\n      joinedConfig: config,\n      remoteConfig: sessionReplayRemoteConfig,\n    };\n  }\n}\n\nexport const createSessionReplayJoinedConfigGenerator = async (apiKey: string, options: SessionReplayOptions) => {\n  const localConfig = new SessionReplayLocalConfig(apiKey, options);\n\n  const remoteConfigClient = new RemoteConfigClient(\n    apiKey,\n    localConfig.loggerProvider,\n    localConfig.serverZone,\n    options.configServerUrl,\n  );\n\n  return new SessionReplayJoinedConfigGenerator(remoteConfigClient, localConfig);\n};\n"]}